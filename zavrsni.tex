\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs}
\usepackage[unicode]{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{subcaption}

\begin{document}

\thesisnumber{6296}

\title{Primjena sustava LCS na klasifikacijske probleme}

\author{Matija Bertović}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}
Ljudi često prilikom zaključivanja i rješavanja problema koriste znanje već stečeno susrećući se s jednostavnijim problemima unutar sličnog područja.
Zašto ne pokušati napraviti i sustav temeljen na tehnikama umjetne inteligencije koji ima iste sposobnosti?
U tom slučaju, sustav ne bi svaki problem morao učiti ispočetka, nego bi već sadržavao neko znanje sakupljeno tijekom učenja na manjim problemima.
Na taj bismo način mogli ubrzati vrijeme potrebno za učenje većih problema.
Potrebno je pronaći sustav koji bi mogao imati tu sposobnost.
Sustav bi trebao moći prikupiti i spremiti znanje naučeno na nekom problemu.
Prikupljeno znanje kasnije bi trebalo moći biti iskorišteno prilikom učenja zahtjevnijih problema unutar slične domene.

Sustav koji može omogućiti navedenu funkcionalnost i koji je detaljnije analiziran u ovom radu naziva se sustav LCS \engl{Learning Classifier System}.
Sustav se sastoji od većeg broja pravila, u kojima je sadržano znanje koje on posjeduje.
To znanje kasnije će biti izvučeno i korišteno pri stvaranju novih pravila.

Klasični sustav LCS nema mogućnost iskorištavanja već prikupljenog znanja, nego svaki problem mora učiti od nule, stoga je potrebna promjena koja će to omogućiti.
Sustav je nadograđen, te umjesto klasične ternarne abecede sadrži binarna stabla, slična onima generiranima tehnikama genetskog programiranja.

Sustav je testiran na 4 različita problema booleovih funkcija: problem multipleksora, problem većinskog bita, problem parnog pariteta i problem bita prijenosa.
Prilikom implementacije, korištena je ideja Willsonovog XCS sustava temeljenog na preciznosti \citep{2}.

U poglavlju \ref{ch:podr} dan je kratak pregled područja.
Poglavlje \ref{ch:prob} daje detaljniji opis gore navedenih problema koji su rješavani u ovom radu.
Način rada sustava i detaljan opis koriptenih algoritama opisan je u poglavlju \ref{ch:algs}.
Rezultati dobiveni primjenom razvijenog sustava opširno su prikazani grafovima i komentirani u poglavlju \ref{ch:rec}.
Rad je zaključen i dan je prijedlog budućeg razvoja u poglavlju \ref{ch:zak}.

\chapter{Pregled područja} \label{ch:podr}
Sustavi LCS su sustavi temeljeni na pravilima, koji povezuju evolucijsko računarstvo i strojno učenje kako bi se što bolje prilagodili rješavanju danog problema.
Sustav je u međudjelovanju s nepoznatom okolinom, od koje pomoću osjetila \engl{sensors} dobiva ulaz, a preko djelovatelja \engl{effectors} nad njom izvršava određenu akciju \citep{4}.
Sustav se sastoji od skupa određenog broja pravila koja zajedno rješavaju neki problem.
Bitno je naglasiti da poanta učenja nije pronaći jedno pravilo koje na kraju rješava dani problem, nego razviti cijelu populaciju pravila koja ga međusobno rješavaju.
Pravila su najčešće u obliku "AKO \emph{uvjet} ONDA \emph{akcija}".
Uvjet pravila većinom je tvoren od znakova ternarne abecede {0, 1, \#}.
Znakovi 0 i 1 moraju se podudarati s odgovarajućim znakovima ulaza, dok se znak \# podudara s bilo kojim znakom.
Znak \# zovemo \emph{don't care simbolom} \engl{don't care symbol}\footnote{U literaturi se još može naći naziv \emph{wildcard}.} i on omogućava generaliziranje.
Problemi su najčešće takvi da je prostor pretraživanja jako velik i nije moguće doslovno naučiti svaki primjer, nego je potrebna sposobnost generaliziranja.
Prilikom istraživanja novih pravila koriste se tehnike evolucijskog računarstva.

Evolucijsko računarsvo bavi se algoritmima pretraživanja temeljenima na prirodnoj selekciji.
Ideja ovog pristupa je da se od početne proizvoljno generirane populacije jedinki, postupcima prirodne selekcije, križanja i mutacije, postupno generiraju bolje i prilagođenije jedinke.
Detaljna razrada evolucijskog računarstva ne ulazi u opseg ovog rada, stoga ono ovdje neće biti detaljnije opisano.
Više informacija čitatelj može pronaći u \citep{6}.

Prilikom rada LCS sustava, pravila djeluju zajedno, ali neka su \emph{bolja} i imaju veću sposobnost generaliziranja od drugih.
Kako bi razlikovali različita pravila i u kojoj mjeri ona utječu na konačni ishod sustava, pravilima se dodjeljuju razni parametri.
Ažuriranje tih parametara obavlja se tehnikama potpornog učenja, koje usmjerava potragu za boljima pravilima \citep{3}.

Potporno učenje je učenje temeljeno na pokušajima, nakon kojih sustav dobije određenu brojčanu nagradu.
U ovisnosti o nagradi, sustav podešava svoje parametre s ciljem povećavanja buduće nagrade te se na taj način prilagođava problemu kojeg rješava.
Detaljan opis postupaka potpornog učenja također izlazi iz opsega ovog rada, stoga čitatelj više informacija može pronaći u \citep{7}.

Dva glavna pristupa u implementaciji LCS sustava su \emph{Michigan-Style} LCS i \emph{Pittsburgh-Style} LCS.
Glavna razlika je u tome što \emph{Pittsburgh-Style} LCS sustav koristi više skupova pravila, od kojih je svaki od tih skupova moguće konačno rješenje, a genetski algoritam djeluje na jednom cijelom skupu pravila. S obzirom da \emph{Pittsburgh-Style} LCS nije tema ovog rada, u nastavku je dan detaljniji opis \emph{Michigan-Style} LCS sustava.

\emph{Michigan-Style} LCS (u nastavku samo LCS) sustav prvi je formalizirao John Holland i u suradnji s Judith Reitman dao njegovu implementaciju.
S obzirom na složenost originalnog LCS sustava, malo jednostavniju i razumljiviju inačicu dao je Stewart W. Wilson pod nazivom ZCS (\emph{"zeroth-level" classifier system}).
Nakon toga, Wilson je uveo još jednu inačicu LCS sustava pod nazivom XCS, u kojemu je promijenio način na koji se računa $dobrota$ pojedinih pravila.
U sklopu ovog rada obrađen je sustav XCS, koji je detaljno objašnjen u poglavljima koja slijede, a za detaljniji opis LCS i ZCS sustava čitatelj se upućuje na \citep{3}.

\chapter{Opis problema} \label{ch:prob}
Problemi testirani u ovom radu su:
\begin{enumerate}
    \item multipleksor \engl{multiplexer},
    \item paritetni bit \engl{parity},
    \item najzastupljeniji bit \engl{majority-on},
    \item bit prijenosa binarnog zbrajala \engl{carry}.
\end{enumerate}

Najviše pažnje posvećeno je rješavanju multipleksora.
Na slici \ref{img:mux} prikazan je multipleksor 4/1.
Multipleksor 4/1 ima 2 upravljačka bita i 4 ulazna bita te jedan izlazni bit.
Upravljački bitovi određuju točno jedan ulazni bit koji se dalje prosljeđuje na izlaz, kako je prikazano u tablici \ref{tbl:mux}.
\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{img/mux.pdf}
    \caption{Multipleksor 4/1.}
    \label{img:mux}
\end{figure}
Općenito, multipleksor koji ima $k$ upravljačkih bitova funkcionira na isti način.
$k$ upravljačkih bitova može adresirati $2^{k}$ ulaznih bitova, stoga je multipleksor s $k$ upravljačkih bitova funkcija od $k + 2^{k}$ varijabli.
Izlaz iz multipleksora je uvijek točno 1 bit, koji ima vrijednost 0 ili 1.
Primjer 4/1 multipleksora prikazanog nizom od 6 bitova je 011010.
U ovom primjeru prva dva bita, 01, označavaju da je izlaz iz multipleksora drugi od preostalih bitova, odnosno 0.
\begin{table}[!htb]
    \caption{Opis rada multipleksora 4/1.}
    \label{tbl:mux}
    \centering
    \begin{tabular}{c | c | c}
        $S_{1}$ & $S_{0}$ & $Y$     \\ \hline
              0 &       0 & $D_{0}$ \\
              0 &       1 & $D_{1}$ \\
              1 &       0 & $D_{2}$ \\
              1 &       1 & $D_{3}$ \\
    \end{tabular}
\end{table}

Problem paritetnog bita svodi se na ispitivanje broja pojavljivanja bita 1 unutar ulaza.
Ako je broj pojavljivanja bita 1 paran, izlaz treba biti 1, a u suprotnom 0.
Primjer 6-bitnog ulaza je 011010, gdje je broj pojavljivanja bita 1 3, stoga izlaz treba biti 0.

Prilikom problema najzastupljenijeg bita, ispituje se frekvencija pojavljivanja pojedinih bitova.
Izlaz je onaj bit koji se pojavljuje više puta.
Na primjer, ako je 5-bitni ulaz 01101, bit 1 se pojavljuje 3 puta, a bit 0 2 puta, stoga izlaz treba biti 1.
Ulaz za ovaj problem će uvijek biti neparne duljine, da izbjegnemo situaciju u kojoj se svaki bit pojavljuje jednak broj puta.

U posljednjem problemu, izlaz mora biti bit prijenosa prilikom zbrajanja dva binarna broja jednake duljine.
Osigurano je da je ulaz uvijek parne duljine, kako bi mogao biti podijeljen na dva binarna broja.
Ako ulaz ima $n$ bitova, prvih $n / 2$ bitova odgovara prvom broju, a posljednjih $n / 2$ bitova drugom broju.
Primjer ulaza za računanje prijenosa prilikom zbrajanja dva 3-bitna binarna broja je 011110, gdje je prvi broj 011, a drugi 110.
Izlaz je ovdje 1, jer je nakon zbrajanja prijenos 1.

\chapter{Opis algoritama} \label{ch:algs}
U sklopu razrade ovog sustava, potrebno je ostvariti iskorištavanje znanja već naučenog na jednostavnijim problemima.
Klasični bitovi uvjeta u ranije opisanim pravilima nam to onemogućavaju.
Iz tog razloga, svaki bit uvjeta zamijenjen je programskim isječkom, koji ovisno o ulazu, vraća 0 ili 1.
Takav XCS sustav, koji koristi programske isječke umjesto uvjetnih bitova, naziva se XCSCFC\footnote{Kratica dolazi od engleskog "\emph{XCS with code-fragment conditions}".}.
Na taj način, prilikom stvaranja novih pravila, ona mogu sadržavati programske isječke izvučene iz klasifikatora koji su rješavali jednostavniji problem u istoj domeni.
Prilikom preuzimanja programskih isječaka, u obzir dolaze samo precizni i iskusni klasifikatori čija dobrota \engl{fitness} je veća od prosječne unutar te populacije klasifikatora \citep{4}.

U ovom radu, isječci koda modelirani su binarnim stablima duljine do najviše 2, što znači da je moguće imati najviše 7 čvorova.
Skup funkcija koje čvorovi mogu obavljati je $\{AND, OR, NAND, NOR, NOT\}$.
U primjerima, te se funkcije redom označavaju s $\&, |, d, r, \sim$.
Skup mogućih završnih (terminalnih) čvorova pojedinog binarnog stabla je $\{D_{0}, D_{1}, ..., D_{n - 1}\}$, gdje \emph{n} predstavlja duljinu ulaza dobivenog od okoline.
Svaki završni čvor predstavlja točno jedan bit ulaza.
Svaki programski isječak na ulaz dobiva cijeli ulaz dobiven od okoline, a na izlazu vraća rezultat operacija koje se nalaze u čvorovima stabla.
Na slici \ref{tree} prikazan je primjer jednog takvog binarnog stabla koje vraća rezultat operacije $D_{3}D_{1}dD_{0}D_{1}|\&$.
Operacija je zbog jednostavnosti prikazana u \emph{postfiks} obliku.
Iz slike je vidljivo da se u binarnom stablu ne moraju pojavljivati svi bitovi ulaza, a također i da se pojedini bitovi mogu pojavljivati više puta.
\begin{figure}[h]
    \centering
    \includegraphics[width=8cm]{img/tree.pdf}
    \caption{Primjer programskog isječka prikazanog binarnim stablom.}
    \label{tree}
\end{figure}

Potreban je i programski isječak koji označava \emph{don't care} simbol, a koji za svaki niz bitova koje dobije na ulazu, na izlazu vraća 1.
On je prikazan na slici \ref{dnc} i označava operaciju $D_{0}D_{0}\sim|$, a preuzet je iz \citep{4}.
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{img/dnc.pdf}
    \caption{Isječak koda korišten kao \emph{don't care} simbol.}
    \label{dnc}
\end{figure}

Prije detaljnog objašnjenja korištenih algoritama, potrebno je naglasiti da su u implementaciji korišteni makroklasifikatori \engl{macroclassifiers} \citep{2}.
Makroklasifikatori su klasifikatori koji imaju dodatan parametar brojnosti \engl{numerosity}.
Razlog korištenju makroklasifikatora je bolja vremenska i prostorna složenost sustava.
Naime, klasifikatori koji imaju jednaki uvjet i akciju sadržani su u istom klasifikatoru, ali je njegova brojnost u tom slučaju veća od 1.
Brojnost klasifikatora $cl$ sadržana je u parametru $cl.n$.
Ako u populaciji postoji $n$ klasifikatora koji imaju jednak uvjet i akciju, to je zapisano u jednom klasifikatoru čija je brojnost u tom slučaju postavljena na $n$.
Kod korištenja makroklasifikatora, prilikom svih izračuna potrebno je u obzir uzeti i parametar brojnosti.

U \emph{Explore} načinu rada, na početku se od okoline dobije ulazni podatak \emph{s}.
U ovisnosti o \emph{s}, formira se \emph{podudarni skup} \engl{Match set} [\emph{M}].
[\emph{M}] se sastoji od svih klasifikatora iz populacije [\emph{P}] koji odgovaraju ulazu \emph{s}.

Za klasifikator \emph{cl}\footnote{Od engleskog "\emph{Classifier}"} kažemo da odgovara ulazu \emph{s}, ako svaki programski isječak za zadani ulaz \emph{s} na izlazu daje 1.
S obzirom da svaki programski isječak unutar uvjeta klasifikatora na ulaz dobiva cijeli \emph{s}, poredak programskih isječaka uopće nije bitan.
Algoritam \ref{match} prikazuje postupak evalucaije klasifikatora \emph{cl} u odnosu na ulaz \emph{s}.
Pri tome \emph{cf} označava \emph{i}-ti programski isječak unutar zadanog klasifikatora \emph{cl}, a \emph{val} rezultat programskog isječka \emph{cf} s obzirom na zadani ulaz \emph{s}.
\emph{n} je duljina uvjeta unutar pravila, odnosno broj programskih isječaka koji se nalaze u klasifikatoru.
\emph{cl.cond} je polje svih programskih isječaka.
Algoritam vraća vrijednost \emph{true} ako svaki programski isječak za zadani ulaz \emph{s} vraća vrijednost 1, a \emph{false} inače.

\begin{algorithm}
    \caption{Evaluiranje klasifikatora $cl$ u odnosu na ulaz $s$}
    \label{match}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl$ -- klasifikator, $s$ -- stanje okoline.}
        \STATE{\textbf{Izlaz:} odgovara li klasifikator $cl$ stanju $s$}
        \FOR{($i := 0; i < n; i := i + 1$)}
        \STATE{$cf := cl.cond[i]$}
        \STATE{$val := evaluiraj(cf, s)$}
        \IF{$val \neq 1$}
        \RETURN{$false$}
        \ENDIF
        \ENDFOR
        \RETURN{$true$}
    \end{algorithmic}
\end{algorithm}

Nakon formiranja [\emph{M}], provjerava se sadrži li [\emph{M}] sve moguće akcije \emph{a}.
U slučaju da za neku akciju ne postoji pripadni klasifikator, pokreće se operacija pokrivanja \engl{Covering Operation}, prikazana algoritmom \ref{cover}.
U operaciji pokrivanja stvara se novi klasifikator čiji je svaki programski isječak \emph{don't care} simbol s vjerojatnošću $P_{don'tCare}$, a s vjerojatnošću $1 - P_{don'tCare}$ proizvoljno generirani programski isječak, koji s obzirom na stanje $s$ mora vraćati 1.
U prikazanom algoritmu, $cl.action$ sadrži akciju koju zagovara pravilo $cl$.
Operacija pokrivanja pokreće se za svaku akciju koja nedostaje u [\emph{M}], a novi klasifikator se dodaje u [\emph{P}] i [\emph{M}].

\begin{algorithm}
    \caption{Operacija pokrivanja}
    \label{cover}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $s$ -- ulaz dobiven iz okoline, $a$ -- akcija koju se pokriva.}
        \STATE{\textbf{Izlaz:} Generirano novo pravilo $cl$}
        \STATE{$cl$ := inicijaliziraj novo pravilo}
        \FOR{($i := 0; i < n; i := i + 1$)}
        \STATE{$r$ := proizvoljan decimalni broj iz intervala [0, 1)}
        \IF{$r < P_{don'tCare}$}
        \STATE{$cl.cond[i]$ := \emph{don't care} simbol}
        \ELSE
        \REPEAT
        \STATE{$cf$ := generiraj proizvoljni programski isječak}
        \STATE{$val := evaluiraj(cf, s)$}
        \UNTIL{$val \neq 1$}
        \STATE{$cl.cond[i] := cf$}
        \ENDIF
        \ENDFOR
        \STATE{$cl.action := a$}
        \RETURN{$cl$}
    \end{algorithmic}
\end{algorithm}

Nakon svakog novog dodavanja pravila u [\emph{P}], pokreće se operacija brisanja \citep{1}.
S obzirom da je potrebno zadržati maksimalnu veličinu populacije $N$, ako je trenutna veličina populacije veća od $N$, izabiru se klasifikatori koje je potrebno izbrisati.
Operacija brisanja prikazana je algoritmom \ref{del}.
Klasifikator se za brisanje odabire \emph{Roulette-Wheel} postupkom, na temelju glasova koje dale svaki klasifikator.
\begin{algorithm}
    \caption{Operacija brisanja}
    \label{del}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $[P]$ -- populacija.}
        \STATE{\textbf{Izlaz:} -}
        \STATE{$velicinaPopulacije := \sum_{cl \in [P]} cl.n$}
        \IF{$velicinaPopulacije \leq N$}
        \RETURN
        \ENDIF
        \STATE{$prosjecnaDobrota := (\sum_{cl \in [P]} cl.F \cdot cl.n) / velicinaPopulacije$}
        \STATE{$sumaGlasova := 0$}
        \FOR{(klasifikator $cl$ iz $[P]$)}
        \STATE{$sumaGlasova := sumaGlasova + glas(cl, prosjecnaDobrota)$}
        \ENDFOR
        \STATE{$r$ := proizvoljan decimalni broj iz intervala [0, 1)}
        \STATE{$odabir := r \cdot sumaGlasova$}
        \STATE{$sumaGlasova := 0$}
        \FOR{(klasifikator $cl$ iz $[P]$)}
        \STATE{$sumaGlasova := sumaGlasova + glas(cl, prosjecnaDobrota)$}
        \IF{$odabir < sumaGlasova$}
        \IF{$cl.n > 1$}
        \STATE{$cl.n := cl.n - 1$}
        \ELSE
        \STATE{izbaci klasifikator $cl$ iz populacije $[P]$}
        \ENDIF
        \RETURN
        \ENDIF
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
Postupak izračuna glasova prikazan je algoritmom \ref{vote}.
Glas svakog klasifikatora temelji se na prosječnoj veličini akcijskog skupa.
Razlog tomu je pokušaj ostvarenja približno jednakih veličina akcijskih skupova.
Također, ako je klasifikator dovoljno iskusan, a dobrota klasifikatora je znatno manja od prosječne dobrote unutar populacije, vjerojatnost njegovog izbacivanja se dodatno povećava u ovisnosti o njegovoj dobroti.
Time je osigurano izbacivanje lošijih klasifikatora.
Iskustvo klasifikatora $cl$ određeno je brojem pojavljivanja tog klasifikatora unutar akcijskog skupa i pamti se u varijabli $cl.exp$.
Konstanta $\theta_{del}$ određuje granicu iskustva nakon koje se može reći da je klasifikator dovoljno iskusan za brisanje.
Konstanta $\delta$ ($0 < \delta \leq 1$) određuje minimalni postotak prosječne dobrote populacije koju klasifikator mora imati da se njegov glas ne bi dodatno povećao.
Vjerojatnost odabira svakog klasifikatora prilikom \emph{Roulette-Wheel} postupka jednaka je postotku glasa tog klasifikatora u odnosu na ukupnu sumu glasova.
Ako je brojnost klasifikatora veća od 1, ona se samo umanjuje za 1.
Nakon što je klasifikator $cl$ izabran za brisanje, provjerava se njegova brojnost sadržana u $cl.n$.
U suprotnom, klasifikator se izbacuje iz populacije.

\begin{algorithm}
    \caption{Glas}
    \label{vote}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl$ -- klasifikator čiji glas računamo, $prosjecnaDobrota$ -- prosječna dobrota populacije.}
        \STATE{\textbf{Izlaz:} $glas$ -- glas klasifikatora $cl$}
        \STATE{$vote := cl.as \cdot cl.n$}
        \IF{$cl.exp > \theta_{del}$ and $cl.F / cl.n < \delta \cdot prosjecnaDobrota$}
        \STATE{$vote := vote \cdot prosjecnaDobrota / (cl.F / cl.n)$}
        \ENDIF
        \RETURN{$glas$}
    \end{algorithmic}
\end{algorithm}

Nakon formiranja podudarnog skupa [\emph{M}], potrebno je odrediti akciju koju će sustav izvršiti.
Akcija se određuje na temelju klasifikatora sadržanih u [\emph{M}].
Za svaku akciju, potrebno je izračunati srednju vrijednost nagrade koju sustav očekuje izvršavanjem te akcije.
Ona se označava funkcijom $P(a)$ i računa po formuli \eqref{eq:pred}.
\begin{equation}
    \label{eq:pred}
    P(a) = \frac{\sum_{cl \in [M] \land cl.a = a} cl.p \cdot cl.F \cdot cl.n}{\sum_{cl \in [M] \land cl.a = a} cl.F \cdot cl.n}
\end{equation}
Vrijednosti $P(a)$ za svaku moguću akciju tvore \emph{polje predviđanja} \engl{prediction array}.
Ovisno o vrijednostima $P(a)$, \emph{Roulette-Wheel} postupkom se izabire konačna akcija koju sustav izvršava\footnote{
Akcija može biti izabrana i nekim drugim postupkom, npr. proizvoljno (\emph{pure exploration}) ili se može odabrati akcija s najvećom $P(a)$ vrijednosti (\emph{pure exploitation}).
Također, može se koristiti proizvoljna akcija s određenom vjerojatnošću, a u suprotnom najbolja.
Takav postupak odgovarao bi \emph{$\epsilon$-greedy} postupku odabira u potpornom učenju, gdje bi $\epsilon$ vrijednost odgovarala vjerojatnosti odabira proizvoljne akcije, kako je navedeno u \citep{1}.}.
Vjerojatnost da će akcija $a$ biti izabrana proporcionalna je vrijednosti $P(a)$.

Nakon odabira akcije $a$, formira se akcijski skup \engl{Action set} [\emph{A}].
[\emph{A}] se sastoji od svih klasifikatora iz [\emph{M}] koja zagovaraju $a$.
Nakon formiranja akcijskog seta izvršava se odabrana akcija $a$ i u ovisnosti o izvršenoj akciji od okoline stiže nagrada $R$.

Po dobitku nagrade, dolazi do ažuriranja parametara svih klasifikatora sadržanih u [\emph{A}].
Redom se ažuriraju iskustvo klasifikatora \engl{Experience} $exp$, njegovo predviđanje \engl{Prediction} $p$, pogreška u predviđanju \engl{Prediction error} $\epsilon$, preciznost \engl{Accuracy} $\kappa$, relativna preciznost \engl{Relative accuracy} $\kappa'$, dobrota $F$ i prosječna veličina akcijskih skupova koji su sadržavali taj klasifikator \engl{Action set size} $as$.
Iskustvo klasifikatora $cl$, $cl.exp$, je broj pojavljivanja $cl$ u akcijskom skupu i ažurira se po formuli \eqref{eq:exp}.
\begin{equation}
    \label{eq:exp}
    cl.exp := cl.exp + 1
\end{equation}
Predviđanje klasifikatora, $cl.p$ procjenjuje nagradu koju sustav očekuje podudaranjem klasifikatora i izvođenjem akcije koju ono zagovara.
Ažurira se po uzoru na Q-učenje, u ovisnosti o dobivenoj nagradi $R$, po formuli \eqref{eq:p}, gdje je $\beta$ realan broj iz intervala $(0, 1]$ i naziva se stopa učenja \engl{learning rate}.
\begin{equation}
    \label{eq:p}
    cl.p := cl.p + \beta \cdot (R - cl.p)
\end{equation}
Pogreška u predviđanju ažurira se u ovisnosti o nagradi $R$ i predviđanju klasifikatora $p$ po formuli \eqref{eq:err}.
\begin{equation}
    \label{eq:err}
    cl.\epsilon := cl.\epsilon + \beta \cdot (|R - cl.p| - cl.\epsilon)
\end{equation}
Prije ažuriranja dobrote $F$ klasifikatora, najprije je potrebno izračunati njegovu preciznost $\kappa$, te ju zatim normalizirati s obzirom na preciznosti ostalih klasifikatora unutar akcijskog skupa, odnosno izračunati relativnu preciznost $\kappa'$.
\begin{equation}
    \label{eq:acc}
    cl.\kappa :=
    \begin{cases}
        1 &\ \mbox{, ako je } \epsilon < \epsilon_{0} \\
        \alpha \cdot \left( \frac{\epsilon}{\epsilon_{0}} \right)^{-\nu} &\ \mbox{, inače}
    \end{cases}
\end{equation}
\begin{equation}
    \label{eq:racc}
    cl.\kappa' := \frac{\kappa}{\sum_{c \in [A]} c.\kappa}
\end{equation}
Pri tome, parametri $\alpha$ $(0 < \alpha < 1)$ i $\nu$ $(\nu > 0)$ kontroliraju brzinu propadanja preciznosti \citep{5}.
Parametar $\epsilon_{0}$ određuje granicu do koje najviše može doći pogreška u predviđanju $\epsilon$, a da bi se za klasifikator moglo reći da je potpuno precizan.
Ako za klasifikator $cl$ vrijedi da je $cl.\epsilon < \epsilon_{0}$, njegova preciznost postaje 1 ($cl.\kappa = 1$), a u suprotnom preciznost ekponencijalno opada ovisno o parametrima $\alpha$ i $\nu$, što je prikazano formulom \eqref{eq:acc}.
Nakon što su izračunate preciznosti svih klasifikatora unutar akcijskog seta [\emph{A}], svaka preciznost se normira ukupnom sumom preciznosti, kao što je prikazano formulom \eqref{eq:racc}.
Kada je izračunata relativna preciznost, dobrota se ažurira prema formuli \eqref{eq:fit}.
\begin{equation}
    \label{eq:fit}
    cl.F := cl.F + \beta \cdot (\kappa' - cl.F)
\end{equation}
Dobrota klasifikatora je procjena njegove preciznosti s obzirom na ostale klasifikatore iz [\emph{A}].
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{img/fit.pdf}
    \caption{Funkcija ovisnosti preciznosti $\kappa$ o pogrešci u predviđanju $\epsilon$. Slika preuzeta iz \citep{5}}
    \label{img:fit}
\end{figure}
Na slici \ref{img:fit} vidi se utjecaj pojedinih parametara prilikom računanja preciznosti $\kappa$.
Parametar $\epsilon_{0}$ određuje do koje granice će klasifikatori imati jednaku, maksimalnu, preciznost, parametar $\alpha$ uvodi značajnu razliku između preciznih i manje preciznih klasifikatora, a parametri $\nu$ i ponovno $\epsilon_{0}$ određuju brzinu opadanja preciznosti.

Nakon postavljanja parametara, postoji mogućnost za pokretanjem operacije istraživanja novih klasifikatora \engl{Discovery component}.
Svaki klasifikator dodatno sadrži i parametar koji pamti kada je zadnji put klasifikator sudjelovao u akcijskom setu nad kojim se provela operacija istraživanja novih pravila.
Operacija otkrivanja novih pravila provodi se ukoliko je prosječno vrijeme proteklo od prošlog pokretanja operacije otkrivanja na klasifikatorima unutar akcijskog seta veće od vremena određenog konstantom $\theta_{GA}$.
Ukoliko to nije zadovoljeno, ovaj se korak preskače.

Prilikom operacije otkrivanja, najprije se iz akcijskog skupa izabiru dva roditeljska klasifikatora.
Odabir roditeljskih klasifikatora ostvaren je turnirskom selekcijom \engl{Tournament selection} u ovisnosti o parametru dobrote.
Prilikom turnirske selekcije, nasumično se odabire unaprijed zadani broj klasifikatora, te se kao pobjednika odabire onaj koji od odabranih ima najveću vrijednost dobrote.
Od izabranih roditeljskih klasifikatora stvaraju se dva potomka, od kojih prvotno svaki ima iste programske isječke uvjeta kao jedan od roditelja.

Nakon toga, s vjerojatnošću $\chi$ provodi se križanje \engl{Crossover} potomaka.
Križanje je ostvarenom operacijom križanja u dvije točke \engl{Two-point crossover} kako je prikazano algoritmom \ref{alg:cross}.
\begin{algorithm}[h]
    \caption{Križanje u dvije točke}
    \label{alg:cross}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl_{1}$ -- prvi klasifikator, $cl_{2}$ -- drugi klasifikator.}
        \STATE{\textbf{Izlaz:} -}
        \STATE{$x :=$ proizvoljan decimalni broj iz intervala [0, n)}
        \STATE{$y :=$ proizvoljan decimalni broj iz intervala [0, n)}
        \IF{$x > y$}
        \STATE{zamijeni $x$ i $y$}
        \ENDIF
        \FOR{$(i = x; i <= y; i = i + 1)$}
        \STATE{zamijeni $cl_{1}.cond[i]$ i $cl_{2}.cond[i]$}
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
Prilikom križanja u dvije točke, proizvoljno se odabiru dva mjesta unutar uvjeta klasifikatora koja se križaju, te se zamjene svi programski isječci između njih.
Unutar algoritma, varijabla $n$ sadrži duljinu uvjeta, odnosno broj programskih isječaka.
Programski isječci se ovdje ne mijenjaju, samo se razmjenjuju između potomaka.
Također, prilikom operacije križanja, akcije koje klasifikatori zagovaraju se ne mijenjaju.

Nakon toga, nad potomcima se provodi mutacija, u kojoj svaki programski isječak uvjeta ima vjerojatnost mutacije $\mu$.
Mutacija, za razliku od križanja, djeluje i na uvjete klasifikatora i na akcije.
Tijekom mutacije, svaki \emph{don't care} simbol zamjenjuje se proizvoljno generiranim programskim isječkom koji odgovara stanju $s$ dobivenom iz okoline, a svaki drugi programski isječak zamjenjuje se \emph{don't care} simbolom.
Na poslijetku, akcije potomaka također bivaju mutirane s vjerojatnošću $\mu$, pri čemu se akcija mijenja u bilo koju drugu akciju (u ovom radu su jedine moguće akcije 0 ili 1, stoga 0 postaje 1, a 1 postaje 0).
Nakon mutacije, mutirani potomak još uvijek odgovara stanju $s$.
Operacija mutacije prikazana je algoritmom \ref{alg:mut}
\begin{algorithm}[h]
    \caption{Mutacija}
    \label{alg:mut}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl$ -- klasifikator nad kojim se provodi mutacija, $s$ -- stanje okoline.}
        \STATE{\textbf{Izlaz:} -}
        \FOR{$(i = 1; i <= n; i = i + 1)$}
        \STATE{$r :=$ proizvoljan decimalni broj iz intervala [0, 1)}
        \IF{$r < \mu$}
        \IF{$cl.cond[i] =$ \emph{don't care} simbol}
        \REPEAT
        \STATE{$cf$ := generiraj proizvoljni programski isječak}
        \STATE{$val := evaluiraj(cf, s)$}
        \UNTIL{$val \neq 1$}
        \STATE{$cl.cond[i] := cf$}
        \ELSE
        \STATE{$cl.cond[i]$ := \emph{don't care} simbol}
        \ENDIF
        \ENDIF
        \ENDFOR
        \STATE{$r :=$ proizvoljan decimalni broj iz intervala [0, 1)}
        \IF{$r < \mu$}
        \STATE{$cl.action :=$ proizvoljna akcija različita od $cl.action$}
        \ENDIF
    \end{algorithmic}
\end{algorithm}

Na kraju operacije istraživanja, predviđanje novonastalih potomaka postavlja se na srednju vrijednost predviđanja roditelja, pogreška u predviđanju postavlja se na srednju vrijednost pogreške u predviđanju roditelja pomnoženu faktorom $predictionErrorReduction$, a dobrota na srednju vrijednost dobrote roditelja pomnoženu faktorom $fitnessReduction$, kao što je navedeno u \citep{4}.

Prije dodavanja nastalih potomaka u populaciju, pokreće se operacija provjere obuhvaća li neki od roditelja potomke \engl{GA subsumption}.
Roditelj obuhvaća potomka, ako uvjet roditelja logički obuhvaća uvjet potomka.
Razlog ovoj operaciji je taj što u slučaju da roditelj obuhvaća potomka, dodavanjem potomka u populaciju ne bi se poboljšala sposobnost sustava, jer roditelj sadrži sve informacije koje sadrži i potomak \citep{1}.
Da bi se uopće mogla pokrenuti provjera, roditelj mora biti precizan i dovoljno iskusan.
Konstanta $\theta_{sub}$ sadrži donju granicu iskustva klasifikatora da bi se za njega moglo reći da je dovoljno iskusan za ovu operaciju, dok konstanta $\epsilon_{0}$ sadrži gornju granicu pogreške u predviđanju klasifikatora da bi on bio dovoljno precizan.
Roditelj može obuhvatiti potomka ako oba klasifikatora zagovaraju istu akciju, ako je roditelj precizan i dovoljno iskusan i ako je roditelj općenitiji od potomka.
Uvođenjem programskih isječaka umjesto ternarnih simbola u uvjete klasifikatora, maknuta je važnost poretka programskih isječaka unutar uvjeta.
Iz tog razloga, prilikom ispitivanja je li roditelj općenitiji od djeteta u obzir su uzeti skupovi programskih odsječaka \citep{4}.
Operacija provjere je li jedno pravilo općenitije od drugog prikazana je algoritmom \ref{alg:general}
\begin{algorithm}
    \caption{Općenitije pravilo}
    \label{alg:general}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl_{1}$ -- općenitiji klasifikator, $cl_{2}$ -- specifičniji klasifikator.}
        \STATE{\textbf{Izlaz:} -- je li klasifikator $cl_{1}$ općenitiji od $cl_{2}$}
        \STATE{$x :=$ broj \emph{don't care} simbola u $cl_{1}$}
        \STATE{$y :=$ broj \emph{don't care} simbola u $cl_{2}$}
        \IF{$x \leq y$}
        \RETURN{$false$}
        \ENDIF
        \STATE{$X :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{1}$}
        \STATE{$Y :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{2}$}
        \IF{$X \not \subseteq Y$}
        \RETURN{$false$}
        \ENDIF
        \RETURN{$true$}
    \end{algorithmic}
\end{algorithm}
Da bi klasifikator $cl_{1}$ bio općenitiji od klasifikatora $cl_{2}$, $cl_{1}$ mora imati više \emph{don't care} simbola od klasifikatora $cl_{2}$, a svaki ostali programski isječak klasifikatora $cl_{1}$ mora biti sadržan u $cl_{2}$.
Ako se pokaže da roditelj obuhvaća potomka, umjesto dodavanja tog potomka u populaciju, roditelju se parametar brojnosti povećava za 1.

Nakon provjere obuhvaća li roditelj potomka, pokreće se provjera obuhvaćanja unutar cijelog akcijskog skupa [\emph{A}].
Pretražuje se akcijski skup i pronalazi se klasifikator koji je precizan i dovoljno iskusan, a ima najveći udio \emph{don't care} simbola.
Da bi klasifikator bio precizan i dovoljno iskusan za obuhvaćanje drugih klasifikatora, on mora ispunjavati isti uvjet kao i u prethodnom koraku.
Nakon pronalaženja takvog klasifikatora $cl$, ponovno se prolazi kroz akcijski skup i za svaki klasifikator $c$ od kojega je $cl$ općenitije, klasifikatoru $cl$ se brojnost povećava za brojnost klasifikatora $c$, a klasifikator $c$ se briše iz populacije.

Nadalje, prilikom dodavanja novog klasifikatora $cl$ u populaciju, potrebno je proći kroz ostale klasifikatore u populaciji i provjeriti postoji li već klasifikator koji je jednak klasifikatoru $cl$.
Ako takav klasifikator postoji, $cl$ se ne dodaje u populaciju, nego se pronađenom klasifikatoru brojnost poveća za 1.
Postupak provjere jednakosti klasifikatora također je drugačiji u odnosu na klasični XCS sustav.
Ponovno nije bitno da poredak programskih isječaka u klasifikatorima bude jednak, nego da klasifikatori sadrže jednake isječke, neovisno o poziciji.
Postupak provjere jednakosti klasifikatora prikazan je algoritmom \ref{alg:eq}.
\begin{algorithm}
    \caption{Jednakost pravila}
    \label{alg:eq}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl_{1}$ -- prvi klasifikator, $cl_{2}$ -- drugi klasifikator.}
        \STATE{\textbf{Izlaz:} -- je li klasifikator $cl_{1}$ općenitiji od $cl_{2}$}
        \IF{$cl_{1}.action \neq cl_{2}.action$}
        \RETURN{$false$}
        \ENDIF
        \STATE{$x :=$ broj \emph{don't care} simbola u $cl_{1}$}
        \STATE{$y :=$ broj \emph{don't care} simbola u $cl_{2}$}
        \IF{$x \neq y$}
        \RETURN{$false$}
        \ENDIF
        \STATE{$X :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{1}$}
        \STATE{$Y :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{2}$}
        \IF{$X \neq Y$}
        \RETURN{$false$}
        \ENDIF
        \RETURN{$true$}
    \end{algorithmic}
\end{algorithm}
Da bi klasifikatori bili jednaki, oni moraju zagovarati istu akciju, moraju imati jednak broj \emph{don't care} simbola, a skupovi ostalih programskih isječaka tih klasifikatora moraju biti jednaki.

Prilikom generiranja proizvoljnih programskih isječaka, kao listovi unutar binarnog stabla, osim terminalnih čvorova, koriste se i programski isječci naučeni na jednostavnijim problemima unutar iste domene \citep{4}.
Po završetku učenja određenog problema, sakupljeni su programski isječci sadržani unutar preciznih i iskusnih klasifikatora konačne populacije.
Klasifikator je precizan i dovoljno iskusan za korištenje pri učenju težeg problema ako je njegovo iskustvo veće od konstante $\theta_{re}$ i ako je njegova dobrota veća od prosječne dobrote konačne populacije.
Primjer ponovnog korištenja naučenih programskih isječaka prikazan je u tablici \ref{tbl:reuse}.
U tablici je različitim programskim isječcima dano ime zbog jednostavnijeg referenciranja.
Vidi se da su isječci naučeni na najjednostavnijem 4/1 multipleksoru korišteni kao listovi unutar isječaka 8/1 multipleksora.
Jednako tako, u 16/1 multipleksoru, korišteni su isječci naučeni i na 4/1 i 8/1 multipleksoru.
\begin{table}[!htb]
    \caption{Ponovno korištenje naučenog znanja. Tablica preuzeta iz \citep{4}.}
    \label{tbl:reuse}
    \centering
    \begin{tabular}{c | c | c}
        \multirow{2}{*}{Multipleksor} & \multicolumn{2}{c}{Programski isječak} \\
        & Ime & Izraz \\ \hline
        \multirow{3}{*}{MUX 4/1} & L1\_0 & $D_{1}D_{0}D_{4}dr$ \\
        & L1\_1 & $D_{5}\sim D_{1}D_{0}\&\&$ \\
        & ... & ... \\ \hline
        \multirow{3}{*}{MUX 8/1} & L2\_0 & $L1\_15D_{2}L1\_4r\&$ \\
        & L2\_1 & $L1\_5D_{7}|L1\_11D_{3}\&r$ \\
        & ... & ... \\ \hline
        \multirow{3}{*}{MUX 16/1} & L3\_0 & $L2\_9L1\_7D_{11}|r$ \\
        & L3\_1 & $L1\_10D_{17}|L2\_1D_{0}r\&$ \\
        & ... & ... \\
    \end{tabular}
\end{table}

U \emph{exploit} načinu rada, XCS sustav se ne mijenja, nego izvršava najbolju moguću akciju.
Početak je isti kao i u \emph{explore} načinu rada.
Formira se podudarni skup koji se sastoji od klasifikatora koji odgovaraju ulazu $s$.
U ovisnosti o klasifikatorima sadržanim u [\emph{M}], formira se \emph{polje predviđanja}, na isti način kako je opisano u \emph{explore} načinu rada.
Na temelju formiranog \emph{polja predviđanja}, odabire se akcija $a$ s najvećom vrijednosti $P(a)$.
Ovaj odabir je drugačiji od onog opisanog u \emph{explore} načinu rada, u kojem se akcija $a$ odabire \emph{Roulette-Wheel} postupkom u ovisnosti o vrijednosti $P(a)$.

\emph{Explore} i \emph{exploit} načini rada se međusobno izmjenju, pri čemu \emph{exploit} način rada služi testiranju sposobnosti sustava.

\chapter{Rezultati} \label{ch:res}
Prilikom testiranja rada sustava, korištene vrijednosti parametara sustava su podešene kao u \citep{4}.
Stopa učenja $\beta = 0.2$, stopa propadanja dobrote $\alpha = 0.1$, granica pogreške predviđanja $\epsilon_{0} = 10$, eksponent propadanja dobrote $\nu = 5$, granica prosječnog proteklog vremena prilikom istraživanja novih pravila $\theta_{GA} = 25$, vjerojatnost križanja u dvije točke $\chi = 0.8$, vjerojatnost mutacije $\mu$, granica iskustva pri brisanju klasifikatora $\theta_{del} = 20$, postotak srednje vrijednosti dobrote prilikom brisanja $\delta = 0.1$, granica iskustva prilikom obuhvaćanja $\theta_{sub} = 20$, vjerojatnost pojavljivanja \emph{don't care} simbola $P_{don'tCare} = 0.33$, propadanje pogreške predviđanja $predictionErrorReduction = 0.25$, propadanje dobrote $fitnessReduction = 0.1$.
Veličina turnira prilikom turnirske selekcije je $40\%$ veličine djelotvornog skupa.
Nagrada okoline iznosi 1000 za ispravnu klasifikaciju, a 0 za neispravnu.
Prilikom generiranja novih programskih isječaka, terminalni čvor ima 50\% vjerojatnosti poprimanja programskog isječka naučenog na nižim razinama.
Na osi apscisa nalazi se broj do tad korištenih testnih primjera, a na osi ordinata pomični udio točno klasificiranih primjera prilikom prethodnih 1000 \emph{exploit} iteracija.

Sva testiranja odrađena su na AMD A10-8700p četverojezgrenom procesoru frekvencije 1.8 GHz i radnoj memoriji od 12 GB.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/6muxre.pdf}
        \caption{4/1 multipleksor.}
        \label{fig:6muxre}
    \end{subfigure}
    %\hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/11muxre.pdf}
        \caption{8/1 multipleksor.}
        \label{fig:11muxre}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/20muxre.pdf}
        \caption{16/1 multipleksor.}
        \label{fig:20muxre}
    \end{subfigure}
    %\hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/37muxre.pdf}
        \caption{32/1 multipleksor.}
        \label{fig:37muxre}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu multipleksora s iskorištavanjem već naučenog znanja.}
    \label{fig:muxre}
\end{figure}
Na slici \ref{fig:muxre} prikazani su grafovi ponašanja sustava na problemu multipleksora.
Veličina populacije $N$ redom je 500, 1000, 2000, 5000 za 4/1, 8/1, 16/1 odnosno 32/1 multipleksor.
4/1, 8/1 i 16/1 multipleksori trenirani su na $5 \cdot 10^{5}$ testnih primjera, a 32/1 na $10^{6}$.
Treniranje za 4/1, 8/1 i 16/1 multipleksor trajalo je ukupno oko 7 minuta, dok je treniranje 32/1 multipleksora trajalo otprilike 50 minuta.
Broj mogućih različitih primjera 32/1 multipleksora je $2^{37} \approx 10^{11}$.
Iz slike \ref{fig:37muxre} se vidi da je već nakon otprilike $3 \cdot 10^{5}$ testnih primjera točnost sustava oko 90\% iako je prostor pretraživanja jako velik, XCSCFC se na njemu ponaša poprilično dobro.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/6muxnre.pdf}
        \caption{4/1 multipleksor.}
        \label{fig:6muxnre}
    \end{subfigure}
    %\hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/11muxnre.pdf}
        \caption{8/1 multipleksor.}
        \label{fig:11muxnre}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/20muxnre.pdf}
        \caption{16/1 multipleksor.}
        \label{fig:20muxnre}
    \end{subfigure}
    %\hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/37muxnre.pdf}
        \caption{32/1 multipleksor.}
        \label{fig:37muxnre}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu multipleksora bez iskorištavanja već naučenog znanja.}
    \label{fig:muxnre}
\end{figure}
S obzirom da je, izmeđuostalog, cilj rada bio prikazati kako radi ponovno iskorištavanje naučenog znanja na manjim problemima, za usporedbu, na slici \ref{fig:muxnre} prikazan je graf ponašanja sustava na problemu multipleksora, ali bez korištenja prethodno stečenog znanja.
Ovdje je svaki multipleksor učen od nule, bez znanja o manjim multipleksorima.
Posebno je zanimljivo pogledati sliku \ref{fig:37muxnre} iz koje se vidi da u ovom slučaju, na primjeru 32/1 multipleksora, sustav nije naučio gotovo ništa, nasuprot vrlo dobrom rezultatu prilikom učenja 32/1 multipleksora uz korištenje prethodno stečenog znanja.

\begin{figure}[!h]
    \centering
    \includegraphics[width=12cm]{img/mux_cond/6bitcond.pdf}
    \caption{Prikaz učenja 6 bitnog multipleksora u ovisnosti o broju programskih isječaka koje klasifikatori sadržavaju.}
    \label{img:6bitcond}
\end{figure}
S obzirom da je, uvođenjem programskih isječaka umjesto uvjetnih bitova, maknuta ovisnost duljine ulaza dobivenog od okoline i broja uvjetnih bitova unutar klasifikatora, prilikom korištenja XCSCFC sustava moguće je imati broj programskih isječaka različit od veličine ulaza.
U svrhu testiranja ovisnosti broja programskih isječaka unutar pojedinog klasifikatora i kvalitete XCSCFC sustava, na slici \ref{img:6bitcond} prikazan je graf ponašanja sustava na 4/1 multipleksoru s različitim brojevima programskih isječaka.
Rezultat je očekivan, a vidi se i da između korištenja jednog programskog isječka i korištenja dva programska isječka u ovom primjeru nema razlike.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/majority/3majre.pdf}
        \caption{Problem s 3 bita.}
        \label{fig:3majre}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/majority/5majre.pdf}
        \caption{Problem s 5 bita.}
        \label{fig:5majre}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/majority/7majre.pdf}
        \caption{Problem sa 7 bita.}
        \label{fig:7majre}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu pronalaska bita s najvećom frekvencijom pojavljivanja.}
    \label{fig:majre}
\end{figure}
Rezultati dobiveni na problemu najzastupljenijeg bita prikazani su na slici \ref{fig:majre}.
Veličina populacije $N$ ovdje je redom 500, 1000 i 2000 za 3-, 5- i 7-bitni problem.
Broj testnih primjera za svaku veličinu je $5 \cdot 10^{5}$.
Prostor pretraživanja je ovdje znatno manji od onoga u problemu s multipleksorom, rezultati nisu znatno bolji.
Zanimljivo je primjetiti da je sustav ovdje bolje naučio 7-bitni (slika \ref{fig:7majre}) problem nego 3-bitni (slika \ref{fig:3majre}), a prostor pretraživanja u 7-bitnom problemu je 16 puta veći.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/parity/2pare.pdf}
        \caption{Problem s 2 bita.}
        \label{fig:2pare}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/parity/3pare.pdf}
        \caption{Problem s 3 bita.}
        \label{fig:3pare}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/parity/4pare.pdf}
        \caption{Problem s 4 bita.}
        \label{fig:4pare}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/parity/5pare.pdf}
        \caption{Problem s 5 bita.}
        \label{fig:5pare}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu parnog pariteta.}
    \label{fig:pare}
\end{figure}
Rezultati na problemu parnog pariteta prikazani su na slici \ref{fig:pare}.
Veličina populacije $N$ redom je 200, 300, 400, 500 za 2-, 3-, 4- i 5-bitni problem.
Broj testnih primjera za svaku veličinu je $5 \cdot 10^{5}$.
Iz slike se vidi da je problem s 2 bita (slika \ref{fig:2pare}) riješen s jako velikom točnošću, ali zbog toga što je vjerojatno naučen na pamet.
Iz slike \ref{fig:3pare} se vidi da se već prilikom učenja za 3 bita javljaju problemi.
Na problemu s 5 bita (\ref{fig:5pare}) sustav nije uspio ništa generalizirati i rezultat je skroz proizvoljan.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/carry/4care.pdf}
        \caption{Zbrajanje 2-bitnih brojeva.}
        \label{fig:4care}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/carry/6care.pdf}
        \caption{Zbrajanje 3-bitnih brojeva.}
        \label{fig:6care}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/carry/8care.pdf}
        \caption{Zbrajanje 4-bitnih brojeva.}
        \label{fig:8care}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/carry/10care.pdf}
        \caption{Zbrajanje 5-bitnih brojeva.}
        \label{fig:10care}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu bita prijenosa prilikom binarnog zbrajanja.}
    \label{fig:care}
\end{figure}
Rezultati na problemu određivanja bita prijenosa prilikom zbrajanja binarnih brojeva prikazani su grafom na slici \ref{fig:care}.

\chapter{Zaključak} \label{ch:zak}
XCS sustav pokazao se kao vrlo složen, koji za neke probleme (npr. multipleksor) radi iznimno dobro, a za neke (npr. paritet) poprilično loše.

Zbog podjele sustava u više dijelova koji slijedno djeluju, otvara se puno prostora za isprobavanje.
Sustav ima brojne parametre s kojima se može eksperimentirati i prilagoditi ga problemu koji se rješava.

U okviru ovog rada isproban je rad sustava samo na booleovim funkcijama, ali one predstavljaju temelj za nastavak rada na složenijim problemima.
Budući rad na ovom sustavu može uključivati prilagodbu sustava za klasifikaciju (npr. jednostavnih slika) u više razreda.

Ovaj rad je motiviran radom prikazanim u \citep{4}, no ovdje su rezultati nešto lošiji nego što je prikazano u navedenom radu.
Razlog je najvjerojatnije taj što neki dijelovi nisu najdetaljnije objašnjeni, ali glavna poanta rada je usvojena.

Na primjeru multipleksora pokazano je da korištenje znanja prethodno naučenog na jednostavnijim primjerima unutar iste domene poboljšava rezultate sustava.
Znanje s nižih razina uspješno je sakupljeno i proslijeđeno prilikom učenja na težim problemima u domeni.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

\engtitle{Application of LCS on Classification Problems}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}

