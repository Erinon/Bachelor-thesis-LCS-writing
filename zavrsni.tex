\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs}
\usepackage[unicode]{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{subcaption}

\begin{document}

\thesisnumber{6296}

\title{Primjena sustava LCS na klasifikacijske probleme}

\author{Matija Bertović}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}
Ljudi često prilikom zaključivanja i rješavanja problema koriste znanje već stečeno susrećući se sa jednostavnijim problemima unutar sličnog područja.


\chapter{Pregled područja}
LCS \engl{Learning Classifier Systems} sustavi su sustavi temeljeni na pravilima, koji povezuju evolucijsko računarstvo i strojno učenje kako bi se što bolje prilagodili rješavanju danog problema.
Sustav je u međudjelovanju sa nepoznatom okolinom, od koje pomoću osjetila dobiva ulaz, a preko djelovatelja nad njom izvršava određenu akciju \citep{4}.
Sustav se sastoji od skupa određenog broja pravila koja zajedno rješavaju neki problem.
Bitno je naglasiti da poanta učenja nije pronaći jedno pravilo koje na kraju rješava dani problem, nego razviti cijelu populaciju pravila koja ga međusobno rješavaju.
Pravila su najčešće u obliku "AKO \emph{uvjet} ONDA \emph{akcija}".
Problemi su najčešće takvi da je prostor pretraživanja jako velik i nije moguće doslovno naučiti svaki primjer, nego je potrebna sposobnost generaliziranja.
Prilikom istraživanja novih pravila koriste se tehnike evolucijskog računarstva.

Evolucijsko računarsvo bavi se algoritmima pretraživanja temeljenima na prirodnoj selekciji.
Ideja ovog pristupa je da se od početne proizvoljno generirane populacije jedinki, postupcima prirodne selekcije, križanja i mutacije, postupno generiraju bolje i prilagođenije jedinke.
Detaljna razrada evolucijskog računarstva ne ulazi u opseg ovog rada, stoga ono ovdje neće biti detaljnije opisano.
Više informacija čitatelj može pronaći u \citep{6}.

Prilikom rada LCS sustava, pravila djeluju zajedno, ali neka su \emph{bolja} i imaju veću sposobnost generaliziranja od drugih.
Kako bi razlikovali različita pravila i u kojoj mjeri ona utječu na konačni ishod sustava, pravilima se dodjeljuju razni parametri.
Ažuriranje tih parametara obavlja se tehnikama potpornog učenja, koje usmjerava potragu za boljima pravilima \citep{3}.

Potporno učenje je učenje temeljeno na pokušajima, nakon kojih sustav dobije određenu brojčanu nagradu.
U ovisnosti o nagradi, sustav podešava svoje parametre s ciljem povećavanja buduće nagrade te se na taj način prilagođava problemu kojeg rješava.
Detaljan opis postupaka potpornog učenja također izlazi iz opsega ovog rada, stoga čitatelj više informacija može pronaći u \citep{7}.

Dva glavna pristupa u implementaciji LCS sustava su \emph{Michigan-Style} LCS i \emph{Pittsburgh-Style} LCS.
Glavna razlika je u tome što \emph{Pittsburgh-Style} LCS sustav koristi više skupova pravila, od kojih je svaki od tih skupova moguće konačno rješenje, a genetski algoritam djeluje na jednom cijelom skupu pravila. S obzirom da \emph{Pittsburgh-Style} LCS nije tema ovog rada, u nastavku je dan detaljniji opis \emph{Michigan-Style} LCS sustava.

\emph{Michigan-Style} LCS (u nastavku samo LCS) sustav prvi je formalizirao John Holland i u suradnji sa Judith Reitman dao njegovu implementaciju.
S obzirom na složenost originalnog LCS sustava, malo jednostavniju i razumljiviju verziju dao je Stewart W. Wilson pod nazivom ZCS (\emph{"zeroth-level" classifier system}).
Nakon toga, Wilson je uveo još jednu verziju LCS sustava pod nazivom XCS, u kojemu je promijenio način na koji se računa \emph{fitness} pojedinih pravila. U nastavku slijedi opis navedenih verzija LCS sustava, koji se detaljnije može pročitati u \citep{3}.


\chapter{Opis problema}
Problemi testirani u ovom radu su:
\begin{enumerate}
    \item multipleksor,
    \item paritetni bit,
    \item najzastupljeniji bit,
    \item bit prijenosa binarnog zbrajala.
\end{enumerate}

Najviše pažnje posvećeno je rješavanju multipleksora.
Na slici \ref{img:mux} prikazan je multipleksor 4/1.
Multipleksor 4/1 ima 2 upravljačka bita i 4 ulazna bita te jedan izlazni bit.
Upravljački bitovi određuju točno jedan ulazni bit koji se dalje prosljeđuje na izlaz, kako je prikazano u tablici \ref{tbl:mux}.
\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{img/mux.pdf}
    \caption{Multipleksor 4/1.}
    \label{img:mux}
\end{figure}
Općenito, multipleksor koji ima $k$ upravljačkih bitova funkcionira na isti način.
$k$ upravljačkih bitova može adresirati $2^{k}$ ulaznih bitova, stoga je multipleksor sa $k$ upravljačkih bitova funkcija od $k + 2^{k}$ varijabli.
Izlaz iz multipleksora je uvijek točno 1 bit, koji ima vrijednost 0 ili 1.
Primjer 4/1 multipleksora prikazanog nizom od 6 bitova je 011010.
U ovom primjeru prva dva bita, 01, označavaju da je izlaz iz multipleksora drugi od preostalih bitova, odnosno 0.
\begin{table}[!htb]
    \caption{Opis rada multipleksora 4/1.}
    \label{tbl:mux}
    \centering
    \begin{tabular}{c | c | c}
        $S_{1}$ & $S_{0}$ & $Y$     \\ \hline
              0 &       0 & $D_{0}$ \\
              0 &       1 & $D_{1}$ \\
              1 &       0 & $D_{2}$ \\
              1 &       1 & $D_{3}$ \\
    \end{tabular}
\end{table}

Problem paritetnog bita svodi se na ispitivanje broja pojavljivanja bita 1 unutar ulaza.
Ako je broj pojavljivanja bita 1 paran, izlaz treba biti 1, a u suprotnom 0.
Primjer 6-bitnog ulaza je 011010, gdje je broj pojavljivanja bita 1 3, stoga izlaz treba biti 0.

Prilikom problema najzastupljenijeg bita, ispituje se frekvencija pojavljivanja pojedinih bitova.
Izlaz je onaj bit koji se pojavljuje više puta.
Na primjer, ako je 5-bitni ulaz 01101, bit 1 se pojavljuje 3 puta, a bit 0 2 puta, stoga izlaz treba biti 1.
Ulaz za ovaj problem će uvijek biti neparne duljine, da izbjegnemo situaciju u kojoj se svaki bit pojavljuje jednak broj puta.

U posljednjem problemu, izlaz mora biti bit prijenosa prilikom zbrajanja dva binarna broja jednake duljine.
Osigurano je da je ulaz uvijek parne duljine, kako bi mogao biti podijeljen na dva binarna broja.
Ako ulaz ima $n$ bitova, prvih $n / 2$ bitova odgovara prvom broju, a posljednjih $n / 2$ bitova drugom broju.
Primjer ulaza za računanje prijenosa prilikom zbrajanja dva 3-bitna binarna broja je 011110, gdje je prvi broj 011, a drugi 110.
Izlaz je ovdje 1, jer je nakon zbrajanja prijenos 1.

\chapter{Opis algoritama} \label{algs}
Prilikom razrade ovog sustava, bilo je potrebno ostvariti iskorištavanje znanja već naučenog na jednostavnijim problemima.
Klasični bitovi uvjeta u ranije opisanim pravilima nam to onemogućavaju.
Iz tog razloga, svaki bit uvjeta zamijenjen je programskim isječkom, koji ovisno o ulazu, vraća 0 ili 1.
Takav XCS sustav, koji koristi programske isječke umjesto uvjetnih bitova, naziva se XCSCFC\footnote{Kratica dolazi od engleskog "\emph{XCS with code-fragment conditions}".}.
Na taj način, prilikom stvaranja novih pravila, ona mogu sadržavati programske isječke izvučene iz pravila koja su rješavala jednostavniji problem u istoj domeni.
Prilikom preuzimanja programskih isječaka, u obzir dolaze samo precizna i iskusna pravila čiji \emph{fitness} je veći od prosječnog unutar te populacije pravila. \citep{4}

U ovom radu, isječci koda su modelirani binarnim stablima duljine do najviše 2, što znači da možemo imati najviše 7 čvorova.
Set funkcija koje čvorovi mogu obavljati je $\{AND, OR, NAND, NOR, NOT\}$.
U primjerima, te će se funkcije redom označavati sa $\&, |, d, r, \sim$.
Skup mogućih završnih čvorova pojedinog binarnog stabla je $\{D_{0}, D_{1}, ..., D_{n - 1}\}$, gdje \emph{n} predstavlja duljinu ulaza dobivenog od okoline.
Svaki završni čvor predstavlja točno jedan bit ulaza.
Svaki isječak koda na ulaz dobije cijeli ulaz dobiven od okoline, a na izlaz vraća rezultat operacija koje se nalaze u čvorovima stabla.
Na slici \ref{tree} prikazan je primjer jednog takvog binarnog stabla koje vraća rezultat operacije $D_{3}D_{1}dD_{0}D_{1}|\&$.
Operacija je zbog jednostavnosti prikazana u \emph{postfix} obliku.
Iz slike također vidimo da se u binarnom stablu ne moraju pojavljivati svi bitovi ulaza, a također i da se pojedini bitovi mogu pojavljivati više puta.
\begin{figure}[h]
    \centering
    \includegraphics[width=8cm]{img/tree.pdf}
    \caption{Primjer programskog isječka prikazanog binarnim stablom.}
    \label{tree}
\end{figure}

Potreban je i isječak koda koji označava \emph{don't care} simbol, a koji će za svaki niz bitova koje dobije na ulazu vratiti 1.
On je prikazan na slici \ref{dnc} i označava operaciju $D_{0}D_{0}\sim|$, a preuzet je iz \citep{4}.
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{img/dnc.pdf}
    \caption{Isječak koda korišten kao \emph{don't care} simbol.}
    \label{dnc}
\end{figure}

Prije detaljnog objašnjenja korištenih algoritama, potrebno je naglasiti da su u implementaciji korišteni makroklasifikatori \engl{macroclassifiers} \citep{2}.
Makroklasifikatori su klasifikatori koji imaju dodatan parametar brojnosti \engl{numerosity}.
Razlog korištenju makroklasifikatora je bolja vremenska i prostorna složenost sustava.
Naime, klasifikatori koji imaju jednaki uvjet i akciju sadržani su u istom klasifikatoru, ali je njegova brojnost u tom slučaju veća od 1.
Brojnost klasifikatora $cl$ sadržana je u parametru $cl.n$.
Ako u populaciji postoji $n$ klasifikatora koji imaju jednak uvjet i akciju, to je zapisano u jednom klasifikatoru čija je brojnost u tom slučaju postavljena na $n$.
Kod korištenja makroklasifikatora, prilikom svih izračuna potrebno je u obzir uzeti i parametar brojnosti.

U \emph{Explore} načinu rada, na početku od okoline dobijemo ulazni podatak \emph{s}.
U ovisnosti o \emph{s}, formira se \emph{podudarni skup} \engl{Match set} [\emph{M}].
[\emph{M}] se sastoji od svih pravila iz populacije [\emph{P}] koja odgovaraju ulazu \emph{s}.

Za pravilo \emph{cl}\footnote{Od engleskog "\emph{Classifier}"} kažemo da odgovara ulazu \emph{s}, ako svaki programski isječak za zadani ulaz \emph{s} na izlazu daje 1.
S obzirom da svaki programski isječak unutar uvjeta pravila na ulaz dobiva cijeli \emph{s}, poredak programskih isječaka uopće nije bitan.
Algoritam \ref{match} prikazuje postupak evalucaije pravila \emph{cl} u odnosu na ulaz \emph{s}.
Pri tome \emph{cf} označava \emph{i}-ti programski isječak unutar zadanog pravila \emph{cl}, a \emph{val} rezultat programskog isječka \emph{cf} s obzirom na zadani ulaz \emph{s}.
\emph{n} je duljina uvjeta unutar pravila, odnosno broj programskih isječaka koji se nalaze u pravilu.
\emph{cl.cond} je polje svih programskih isječaka.
Algoritam vraća vrijednost \emph{true} ako svaki programski isječak za zadani ulaz \emph{s} vraća vrijednost 1, a \emph{false} inače.

\begin{algorithm}
    \caption{Evaluiranje pravila $cl$ u odnosu na ulaz $s$}
    \label{match}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl$ -- pravilo, $s$ -- stanje okoline.}
        \STATE{\textbf{Izlaz:} odgovara li pravilo $cl$ stanju $s$}
        \FOR{($i := 0; i < n; i := i + 1$)}
        \STATE{$cf := cl.cond[i]$}
        \STATE{$val := evaluiraj(cf, s)$}
        \IF{$val \neq 1$}
        \RETURN{$false$}
        \ENDIF
        \ENDFOR
        \RETURN{$true$}
    \end{algorithmic}
\end{algorithm}

Nakon formiranja [\emph{M}], provjerava se sadrži li [\emph{M}] sve moguće akcije \emph{a}.
U slučaju da za neku akciju ne postoji pripadno pravilo, pokreće se operacija pokrivanja \engl{Covering Operation}, prikazana algoritmom \ref{cover}.
U operaciji pokrivanja stvara se novo pravilo čiji je svaki programski isječak \emph{don't care} simbol sa vjerojatnošću $P_{don'tCare}$, a sa vjerojatnošću $1 - P_{don'tCare}$ proizvoljno generirani programski isječak, koji s obzirom na stanje $s$ mora vraćati 1.
U prikazanom algoritmu, $cl.action$ sadrži akciju koju zagovara pravilo $cl$.
Operacija pokrivanja pokreće se za svaku akciju koja nedostaje u [\emph{M}], a novo pravilo se dodaje u  [\emph{P}] i [\emph{M}].

\begin{algorithm}
    \caption{Operacija pokrivanja}
    \label{cover}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $s$ -- ulaz dobiven iz okoline, $a$ -- akcija koju se pokriva.}
        \STATE{\textbf{Izlaz:} Generirano novo pravilo $cl$}
        \STATE{$cl$ := inicijaliziraj novo pravilo}
        \FOR{($i := 0; i < n; i := i + 1$)}
        \STATE{$r$ := proizvoljan decimalni broj iz intervala [0, 1)}
        \IF{$r < P_{don'tCare}$}
        \STATE{$cl.cond[i]$ := \emph{don't care} simbol}
        \ELSE
        \REPEAT
        \STATE{$cf$ := generiraj proizvoljni programski isječak}
        \STATE{$val := evaluiraj(cf, s)$}
        \UNTIL{$val \neq 1$}
        \STATE{$cl.cond[i] := cf$}
        \ENDIF
        \ENDFOR
        \STATE{$cl.action := a$}
        \RETURN{$cl$}
    \end{algorithmic}
\end{algorithm}

Nakon svakog novog dodavanja pravila u [\emph{P}], pokreće se operacija brisanja \citep{1}.
S obzirom da je potrebno zadržati maksimalnu veličinu populacije $N$, ako je trenutna veličina populacije veća od $N$, izabiru se pravila koja je potrebno izbrisati.
Operacija brisanja prikazana je algoritmom \ref{del}.
Pravilo se za brisanje odabire \emph{Roulette-Wheel} postupkom, na temelju glasova koje svako pravilo daje.
\begin{algorithm}
    \caption{Operacija brisanja}
    \label{del}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $[P]$ -- populacija.}
        \STATE{\textbf{Izlaz:} -}
        \STATE{$velicinaPopulacije := \sum_{cl \in [P]} cl.n$}
        \IF{$velicinaPopulacije \leq N$}
        \RETURN
        \ENDIF
        \STATE{$prosjecniFitness := (\sum_{cl \in [P]} cl.F \cdot cl.n) / velicinaPopulacije$}
        \STATE{$sumaGlasova := 0$}
        \FOR{(pravilo $cl$ iz $[P]$)}
        \STATE{$sumaGlasova := sumaGlasova + glas(cl, prosjecniFitness)$}
        \ENDFOR
        \STATE{$r$ := proizvoljan decimalni broj iz intervala [0, 1)}
        \STATE{$odabir := r \cdot sumaGlasova$}
        \STATE{$sumaGlasova := 0$}
        \FOR{(pravilo $cl$ iz $[P]$)}
        \STATE{$sumaGlasova := sumaGlasova + glas(cl, prosjecniFitness)$}
        \IF{$odabir < sumaGlasova$}
        \IF{$cl.n > 1$}
        \STATE{$cl.n := cl.n - 1$}
        \ELSE
        \STATE{izbaci pravilo $cl$ iz populacije $[P]$}
        \ENDIF
        \RETURN
        \ENDIF
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
Postupak izračuna glasova prikazan je algoritmom \ref{vote}.
Glas svakog pravila temelji se na prosječnoj veličini akcijskog skupa.
Razlog tomu je pokušaj ostvarenja približno jednakih veličina akcijskih skupova.
Također, ako je pravilo dovoljno iskusno, a $fitness$ pravila je znatno manji od prosječnog $fitness$-a, vjerojatnost njegovog izbacivanja se dodatno povećava u ovisnosti o $fitness$-u.
Time je osigurano izbacivanje lošijih pravila.
Iskustvo pravila $cl$ određeno je brojem pojavljivanja tog pravila unutar akcijskog skupa i pamti se u varijabli $cl.exp$.
Konstanta $\theta_{del}$ određuje granicu iskustva nakon koje se može reći da je pravilo dovoljno iskusno za brisanje.
Konstanta $\delta$ (iz intervala (0, 1]) određuje minimalni postotak prosječnog $fitness$-a populacije kojega pravilo mora imati da se njegov glas ne bi dodatno povećao.
Vjerojatnost odabira svakog pravila prilikom \emph{Roulette-Wheel} postupka jednaka je postotku glasa tog pravila u odnosu na ukupnu sumu glasova.
Nakon što je pravilo $cl$ izabrano za brisanje, provjerava se njegova brojnost \engl(numerosity) sadržana u $cl.n$.
Ako je brojnost pravila veća od 1, ona se samo umanjuje za 1.
U suprotnom, pravilo se izbacuje iz populacije.

\begin{algorithm}
    \caption{Glas}
    \label{vote}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl$ -- pravilo čiji glas računamo, $prosjecniFitness$ -- prosječni $fitness$ populacije.}
        \STATE{\textbf{Izlaz:} $glas$ -- glas pravila $cl$}
        \STATE{$vote := cl.as \cdot cl.n$}
        \IF{$cl.exp > \theta_{del}$ and $cl.F / cl.n < \delta \cdot prosjecniFitness$}
        \STATE{$vote := vote \cdot prosjecniFitness / (cl.F / cl.n)$}
        \ENDIF
        \RETURN{$glas$}
    \end{algorithmic}
\end{algorithm}

Nakon formiranja podudarnog skupa [\emph{M}], potrebno je odrediti akciju koju će sustav izvršiti.
Akcija se određuje na temelju pravila sadržanih u [\emph{M}].
Za svaku akciju, potrebno je izračunati srednju vrijednost nagrade koju sustav očekuje izvršavanjem te akcije.
Ona se označava funkcijom $P(a)$ i računa po formuli \eqref{eq:pred}.
\begin{equation}
    \label{eq:pred}
    P(a) = \frac{\sum_{cl \in [M] \land cl.a = a} cl.p \cdot cl.F \cdot cl.n}{\sum_{cl \in [M] \land cl.a = a} cl.F \cdot cl.n}
\end{equation}
Vrijednosti $P(a)$ za svaku moguću akciju tvore \emph{polje predviđanja} \engl{prediction array}.
Ovisno o vrijednostima $P(a)$, \emph{Roulette-Wheel} postupkom se izabire konačna akcija koju sustav izvršava\footnote{
Akcija može biti izabrana i nekim drugim postupkom, npr. proizvoljno (\emph{pure exploration}) ili se može odabrati akcija s najvećom $P(a)$ vrijednosti (\emph{pure exploitation}).
Također, može se koristiti proizvoljna akcija sa određenom vjerojatnošću, a u suprotnom najbolja.
Takav postupak odgovarao bi \emph{$\epsilon$-greedy} postupku odabira u potpornom učenju, gdje bi $\epsilon$ vrijednost odgovarala vjerojatnosti odabira proizvoljne akcije, kako je navedeno u \citep{1}.}.
Vjerojatnost da će akcija $a$ biti izabrana proporcionalna je vrijednosti $P(a)$.

Nakon odabira akcije $a$, formira se akcijski skup \engl{Action set} [\emph{A}].
[\emph{A}] se sastoji od svih pravila iz [\emph{M}] koja zagovaraju $a$.
Nakon formiranja akcijskog seta izvršava se odabrana akcija $a$ i u ovisnosti o izvršenoj akciji od okoline stiže nagrada $R$.

Po dobitku nagrade, dolazi do ažuriranja parametara svih pravila sadržanih u [\emph{A}].
Redom se ažuriraju iskustvo pravila \engl{Experience} $exp$, njegovo predviđanje \engl{Prediction} $p$, pogreška u predviđanju \engl{Prediction error} $\epsilon$, preciznost \engl{Accuracy} $\kappa$, relativna preciznost \engl{Relative accuracy} $\kappa'$, \emph{fitness} $F$ i prosječna veličina akcijskih skupova koji su sadržavali to pravilo \engl{Action set size} $as$.
Iskustvo pravila $cl$, $cl.exp$, je broj pojavljivanja $cl$ u akcijskom skupu i ažurira se po formuli \eqref{eq:exp}.
\begin{equation}
    \label{eq:exp}
    cl.exp := cl.exp + 1
\end{equation}
Predviđanje pravila, $cl.p$ procjenjuje nagradu koju sustav očekuje podudaranjem pravila i izvođenjem akcije koju ono zagovara.
Ažurira se po uzoru na Q-učenje, u ovisnosti o dobivenoj nagradi $R$, po formuli \eqref{eq:p}, gdje je $\beta$ realan broj iz intervala $(0, 1]$ i naziva se stopa učenja \engl{learning rate}.
\begin{equation}
    \label{eq:p}
    cl.p := cl.p + \beta \cdot (R - cl.p)
\end{equation}
Pogreška u predviđanju ažurira se u ovisnosti o nagradi $R$ i predviđanju pravila $p$ po formuli \eqref{eq:err}.
\begin{equation}
    \label{eq:err}
    cl.\epsilon := cl.\epsilon + \beta \cdot (|R - cl.p| - cl.\epsilon)
\end{equation}
Prije ažuriranja $fitness$-a $F$ pravila, najprije je potrebno izračunati njegovu preciznost $\kappa$, te ju zatim normalizirati s obzirom na preciznosti ostalih pravila unutar akcijskog skupa, odnosno izračunati relativnu preciznost $\kappa'$.
\begin{equation}
    \label{eq:acc}
    cl.\kappa :=
    \begin{cases}
        1 &\ \mbox{, ako je } \epsilon < \epsilon_{0} \\
        \alpha \cdot \left( \frac{\epsilon}{\epsilon_{0}} \right)^{-\nu} &\ \mbox{, inače}
    \end{cases}
\end{equation}
\begin{equation}
    \label{eq:racc}
    cl.\kappa' := \frac{\kappa}{\sum_{c \in [A]} c.\kappa}
\end{equation}
Pri tome, parametri $\alpha$ $(0 < \alpha < 1)$ i $\nu$ $(\nu > 0)$ kontroliraju brzinu propadanja preciznosti \citep{5}.
Parametar $\epsilon_{0}$ određuje granicu do koje najviše može doći pogreška u predviđanju $\epsilon$, a da bi se za pravilo moglo reći da je potpuno precizno.
Ako za pravilo $cl$ vrijedi da je $cl.\epsilon < \epsilon_{0}$, njegova preciznost postaje 1 ($cl.\kappa = 1$), a u suprotnom preciznost ekponencijalno opada ovisno o parametrima $\alpha$ i $\nu$, što je prikazano formulom \eqref{eq:acc}.
Nakon što su izračunate preciznosti svih pravila unutar akcijskog seta [\emph{A}], svaka preciznost se normira ukupnom sumom preciznosti, kao što je prikazano formulom \eqref{eq:racc}.
Kada je izračunata relativna preciznost, $fitness$ se ažurira prema formuli \eqref{eq:fit}.
\begin{equation}
    \label{eq:fit}
    cl.F := cl.F + \beta \cdot (\kappa' - cl.F)
\end{equation}
$Fitness$ vrijednost pravila je procjena njegove preciznosti s obzirom na ostala pravila iz [\emph{A}].
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{img/fit.pdf}
    \caption{Funkcija ovisnosti preciznosti $\kappa$ o pogrešci u predviđanju $\epsilon$. Slika preuzeta iz \citep{5}}
    \label{img:fit}
\end{figure}
Na slici \ref{img:fit} vidi se utjecaj pojedinih parametara prilikom računanja preciznosti $\kappa$.
Parametar $\epsilon_{0}$ određuje do koje granice će pravila imati jednaku, maksimalnu, preciznost, parametar $\alpha$ uvodi značajnu razliku između preciznih i manje preciznih pravila, a parametri $\nu$ i ponovno $\epsilon_{0}$ određuju brzinu opadanja preciznosti.

Nakon postavljanja parametara, postoji mogućnost za pokretanjem operacije istraživanja novih pravila \engl{Discovery component}.
Svako pravilo dodatno sadrži i parametar koji pamti kada je zadnji put pravilo sudjelovalo u akcijskom setu nad kojim se provela operacija istraživanja novih pravila.
Operacija otkrivanja novih pravila provodi se ukoliko je prosječno vrijeme proteklo od prošlog pokretanja operacije otkrivanja na pravilima unutar akcijskog seta veće od vremena određenog konstantom $\theta_{GA}$.
Ukoliko to nije zadovoljeno, ovaj se korak preskače.

Prilikom operacije otkrivanja, najprije se iz akcijskog skupa izabiru dva roditeljska pravila.
Odabir roditeljskih pravila ostvaren je turnirskom selekcijom \engl{Tournament selection} u ovisnosti o $fitness$ parametru.
Prilikom turnirske selekcije, nasumično se odabire unaprijed zadani broj pravila, te se kao pobjednika odabire ono koje od odabranih ima najveću $fitness$ vrijednost.
Od izabranih roditeljskih pravila stvaraju se dva potomka, od kojih prvotno svaki ima iste programske isječke uvjeta kao jedan od roditelja.

Nakon toga, sa vjerojatnošću $\chi$ provodi se križanje \engl{Crossover} potomaka.
Križanje je ostvarenom operacijom križanja u dvije točke \engl{Two-point crossover} kako je prikazano algoritmom \ref{alg:cross}.
\begin{algorithm}[h]
    \caption{Križanje u dvije točke}
    \label{alg:cross}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl_{1}$ -- prvo pravilo, $cl_{2}$ -- drugo pravilo.}
        \STATE{\textbf{Izlaz:} -}
        \STATE{$x :=$ proizvoljan decimalni broj iz intervala [0, n)}
        \STATE{$y :=$ proizvoljan decimalni broj iz intervala [0, n)}
        \IF{$x > y$}
        \STATE{zamijeni $x$ i $y$}
        \ENDIF
        \FOR{$(i = x; i <= y; i = i + 1)$}
        \STATE{zamijeni $cl_{1}.cond[i]$ i $cl_{2}.cond[i]$}
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
Prilikom križanja u dvije točke, proizvoljno se odabiru dva mjesta unutar uvjeta pravila koja se križaju, te se zamjene svi programski isječci između njih.
Unutar algoritma, varijabla $n$ sadrži duljinu uvjeta, odnosno broj programskih isječaka.
Programski isječci se ovdje ne mijenjaju, samo se razmjenjuju između potomaka.
Također, prilikom operacije križanja, akcije koje pravila zagovaraju se ne mijenjaju.

Nakon toga, nad potomcima se provodi mutacija, u kojoj svaki programski isječak uvjeta ima vjerojatnost mutacije $\mu$.
Mutacija, za razliku od križanja, djeluje i na uvjete pravila i na akcije.
Tijekom mutacije, svaki \emph{don't care} simbol zamjenjuje se proizvoljno generiranim programskim isječkom koji odgovara stanju $s$ dobivenom iz okoline, a svaki drugi programski isječak zamjenjuje se \emph{don't care} simbolom.
Na poslijetku, akcije potomaka također bivaju mutirane s vjerojatnošću $\mu$, pri čemu se akcija mijenja u bilo koju drugu akciju (u ovom radu su jedine moguće akcije 0 ili 1, stoga 0 postaje 1, a 1 postaje 0).
Nakon mutacije, mutirani potomak još uvijek odgovara stanju $s$.
Operacija mutacije prikazana je algoritmom \ref{alg:mut}
\begin{algorithm}[h]
    \caption{Mutacija}
    \label{alg:mut}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl$ -- pravilo nad kojim se provodi mutacija, $s$ -- stanje okoline.}
        \STATE{\textbf{Izlaz:} -}
        \FOR{$(i = 1; i <= n; i = i + 1)$}
        \STATE{$r :=$ proizvoljan decimalni broj iz intervala [0, 1)}
        \IF{$r < \mu$}
        \IF{$cl.cond[i] =$ \emph{don't care} simbol}
        \REPEAT
        \STATE{$cf$ := generiraj proizvoljni programski isječak}
        \STATE{$val := evaluiraj(cf, s)$}
        \UNTIL{$val \neq 1$}
        \STATE{$cl.cond[i] := cf$}
        \ELSE
        \STATE{$cl.cond[i]$ := \emph{don't care} simbol}
        \ENDIF
        \ENDIF
        \ENDFOR
        \STATE{$r :=$ proizvoljan decimalni broj iz intervala [0, 1)}
        \IF{$r < \mu$}
        \STATE{$cl.action :=$ proizvoljna akcija različita od $cl.action$}
        \ENDIF
    \end{algorithmic}
\end{algorithm}

Na kraju operacije istraživanja, predviđanje novonastalih potomaka postavlja se na srednju vrijednost predviđanja roditelja, pogreška u predviđanju postavlja se na srednju vrijednost pogreške u predviđanju roditelja pomnoženu faktorom $predictionErrorReduction$, a $fitness$ na srednju vrijednost $fitness$-a roditelja pomnoženu faktorom $fitnessReduction$, kao što je navedeno u \citep{4}.

Prije dodavanja nastalih potomaka u populaciju, pokreće se operacija provjere obuhvaća li neki od roditelja potomke \engl{GA subsumption}.
Roditelj obuhvaća potomka, ako uvjet roditelja logički obuhvaća uvjet potomka.
Razlog ovoj operaciji je taj što u slučaju da roditelj obuhvaća potomka, dodavanjem potomka u populaciju ne bi se poboljšala sposobnost sustava, jer roditelj sadrži sve informacije koje sadrži i potomak \citep{1}.
Da bi se uopće mogla pokrenuti provjera, roditelj mora biti precizan i dovoljno iskusan.
Konstanta $\theta_{sub}$ sadrži donju granicu iskustva pravila da bi se za njega moglo reći da je dovoljno iskusno za ovu operaciju, dok konstanta $\epsilon_{0}$ sadrži gornju granicu pogreške u predviđanju pravila da bi ono bilo dovoljno precizno.
Roditelj može obuhvatiti potomka ako oba pravila zagovaraju istu akciju, ako je roditelj precizan i dovoljno iskusan i ako je roditelj općenitiji od potomka.
Uvođenjem programskih isječaka umjesto ternarnih simbola u uvjete pravila, maknuta je važnost poretka programskih isječaka unutar uvjeta.
Iz tog razloga, prilikom ispitivanja je li roditelj općenitiji od djeteta u obzir su uzeti skupovi programskih odsječaka \citep{4}.
Operacija provjere je li jedno pravilo općenitije od drugog prikazana je algoritmom \ref{alg:general}
\begin{algorithm}
    \caption{Općenitije pravilo}
    \label{alg:general}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl_{1}$ -- općenitije pravilo, $cl_{2}$ -- specifičnije pravilo.}
        \STATE{\textbf{Izlaz:} -- je li pravilo $cl_{1}$ općenitije od $cl_{2}$}
        \STATE{$x :=$ broj \emph{don't care} simbola u $cl_{1}$}
        \STATE{$y :=$ broj \emph{don't care} simbola u $cl_{2}$}
        \IF{$x \leq y$}
        \RETURN{$false$}
        \ENDIF
        \STATE{$X :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{1}$}
        \STATE{$Y :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{2}$}
        \IF{$X \not \subseteq Y$}
        \RETURN{$false$}
        \ENDIF
        \RETURN{$true$}
    \end{algorithmic}
\end{algorithm}
Da bi pravilo $cl_{1}$ bilo općenitije od pravila $cl_{2}$, $cl_{1}$ mora imati više \emph{don't care} simbola od pravila $cl_{2}$, a svaki ostali programski isječak pravila $cl_{1}$ mora biti sadržan u $cl_{2}$.
Ako se pokaže da roditelj obuhvaća potomka, umjesto dodavanja tog potomka u populaciju, roditelju se parametar brojnosti povećava za 1.

Nakon provjere obuhvaća li roditelj potomka, pokreće se provjera obuhvaćanja unutar cijelog akcijskog skupa [\emph{A}].
Pretražuje se akcijski skup i pronalazi se pravilo koje je precizno i dovoljno iskusno, a ima najveći udio \emph{don't care} simbola.
Da bi pravilo bilo precizno i dovoljno iskusno za obuhvaćanje drugih pravila, ono mora ispunjavati isti uvjet kao i u prethodnom koraku.
Nakon pronalaženja takvog pravila $cl$, ponovno se prolazi kroz akcijski skup i za svako pravilo $c$ od kojega je $cl$ općenitije, pravilu $cl$ se brojnost povećava za brojnost pravila $c$, a pravilo $c$ se briše iz populacije.

Nadalje, prilikom dodavanja novog pravila $cl$ u populaciju, potrebno je proći kroz ostala pravila u populaciji i provjeriti postoji li već pravilo koje je jednako pravilu $cl$.
Ako takvo pravilo postoji, $cl$ se ne dodaje u populaciju, nego pronađenom pravilu brojnost poveća za 1.
Postupak provjere jednakosti pravila također je drugačiji u odnosu na klasični XCS sustav.
Ponovno nije bitno da poredak programskih isječaka u pravilima bude jednak, nego da pravila sadrže jednake isječke, neovisno o poziciji.
Postupak provjere jednakosti pravila prikazan je algoritmom \ref{alg:eq}.
\begin{algorithm}
    \caption{Jednakost pravila}
    \label{alg:eq}
    \begin{algorithmic}
        \STATE{\textbf{Ulaz:} $cl_{1}$ -- prvo pravilo, $cl_{2}$ -- drugo pravilo.}
        \STATE{\textbf{Izlaz:} -- je li pravilo $cl_{1}$ općenitije od $cl_{2}$}
        \IF{$cl_{1}.action \neq cl_{2}.action$}
        \RETURN{$false$}
        \ENDIF
        \STATE{$x :=$ broj \emph{don't care} simbola u $cl_{1}$}
        \STATE{$y :=$ broj \emph{don't care} simbola u $cl_{2}$}
        \IF{$x \neq y$}
        \RETURN{$false$}
        \ENDIF
        \STATE{$X :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{1}$}
        \STATE{$Y :=$ skup svih "ne-\emph{don't care}" isječaka u $cl_{2}$}
        \IF{$X \neq Y$}
        \RETURN{$false$}
        \ENDIF
        \RETURN{$true$}
    \end{algorithmic}
\end{algorithm}
Da bi pravila bila jednaka, ona moraju zagovarati istu akciju, moraju imati jednak broj \emph{don't care} simbola i skupovi ostali programskih isječaka tih pravila moraju biti jednaki.

Prilikom generiranja proizvoljnih programskih isječaka, kao listovi unutar binarnog stabla, osim terminalnih čvorova, koriste se i programski isječci naučeni na jednostavnijim problemima unutar iste domene \citep{4}.
Po završetku učenja određenog problema, sakupljeni su programski isječci sadržani unutar preciznih i iskusnih pravila konačne populacije.
Pravilo je precizno i dovoljno iskusno za korištenje pri učenju težeg problema ako je njegovo iskustvo veće od konstante $\theta_{re}$ i ako je njegov $fitness$ veći od prosječnog $fitness$-a konačne populacije.
Primjer ponovnog korištenja naučenih programskih isječaka prikazan je u tablici \ref{tbl:reuse}.
U tablici je različitim programskim isječcima dano ime zbog jednostavnijeg referenciranja.
Vidi se da su isječci naučeni na najjednostavnijem 4/1 multipleksoru korišteni kao listovi unutar isječaka 8/1 multipleksora.
Jednako tako, u 16/1 multipleksoru, korišteni su isječci naučeni i na 4/1 i 8/1 multipleksoru.
\begin{table}[!htb]
    \caption{Ponovno korištenje naučenog znanja. Tablica preuzeta iz \citep{4}.}
    \label{tbl:reuse}
    \centering
    \begin{tabular}{c | c | c}
        \multirow{2}{*}{Multipleksor} & \multicolumn{2}{c}{Programski isječak} \\
        & Ime & Izraz \\ \hline
        \multirow{3}{*}{MUX 4/1} & L1\_0 & $D_{1}D_{0}D_{4}dr$ \\
        & L1\_1 & $D_{5}\sim D_{1}D_{0}\&\&$ \\
        & ... & ... \\ \hline
        \multirow{3}{*}{MUX 8/1} & L2\_0 & $L1\_15D_{2}L1\_4r\&$ \\
        & L2\_1 & $L1\_5D_{7}|L1\_11D_{3}\&r$ \\
        & ... & ... \\ \hline
        \multirow{3}{*}{MUX 16/1} & L3\_0 & $L2\_9L1\_7D_{11}|r$ \\
        & L3\_1 & $L1\_10D_{17}|L2\_1D_{0}r\&$ \\
        & ... & ... \\
    \end{tabular}
\end{table}

U \emph{exploit} načinu rada, XCS sustav se ne mijenja, nego izvršava najbolju moguću akciju.
Početak je isti kao i u \emph{explore} načinu rada.
Formira se podudarni skup koji se sastoji od klasifikatora koji odgovaraju ulazu $s$.
U ovisnosti o klasifikatorima sadržanim u [\emph{M}], formira se \emph{polje predviđanja}, na isti način kako je opisano u \emph{explore} načinu rada.
Na temelju formiranog \emph{polja predviđanja}, odabire se akcija $a$ sa najvećom vrijednosti $P(a)$.
Ovaj odabir je drugačiji od onog opisanog u \emph{explore} načinu rada, u kojem se akcija $a$ odabire \emph{Roulette-Wheel} postupkom u ovisnosti o vrijednosti $P(a)$.

\emph{Explore} i \emph{exploit} načini rada se međusobno izmjenju, pri čemu \emph{exploit} način rada služi testiranju sposobnosti sustava.

\chapter{Rezultati}
Prilikom testiranja rada sustava, korištene vrijednosti parametara sustava su podešene kao u \citep{4}.
Stopa učenja $\beta = 0.2$, stopa propadanja dobrote $\alpha = 0.1$, granica pogreške predviđanja $\epsilon_{0} = 10$, eksponent propadanja dobrote $\nu = 5$, granica prosječnog proteklog vremena prilikom istraživanja novih pravila $\theta_{GA} = 25$, vjerojatnost križanja u dvije točke $\chi = 0.8$, vjerojatnost mutacije $\mu$, granica iskustva pri brisanju klasifikatora $\theta_{del} = 20$, postotak srednje vrijednosti dobrote prilikom brisanja $\delta = 0.1$, granica iskustva prilikom obuhvaćanja $\theta_{sub} = 20$, vjerojatnost pojavljivanja \emph{don't care} simbola $P_{don'tCare} = 0.33$, propadanje pogreške predviđanja $predictionErrorReduction = 0.25$, propadanje dobrote $fitnessReduction = 0.1$.
Veličina turnira prilikom turnirske selekcije je $40\%$ veličine djelotvornog skupa.
Nagrada okoline iznosi 1000 za ispravnu klasifikaciju, a 0 za neispravnu.
Na osi apscisa nalazi se broj do tad korištenih testnih primjera, a na osi ordinata pomični udio točno klasificiranih primjera prilikom prethodnih 1000 \emph{exploit} iteracija.

\begin{figure}
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/6muxre.pdf}
        \caption{Problem sa 6 bita.}
        \label{fig:6muxre}
    \end{subfigure}
    %\hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/11muxre.pdf}
        \caption{Problem sa 11 bita.}
        \label{fig:11muxre}
    \end{subfigure} \\
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/20muxre.pdf}
        \caption{Problem sa 20 bita.}
        \label{fig:20muxre}
    \end{subfigure}
    %\hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/multiplexer/37muxre.pdf}
        \caption{Problem sa 37 bita.}
        \label{fig:37muxre}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu multipleksora.}
    \label{fig:muxre}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/majority/3majre.pdf}
        \caption{Problem sa 3 bita.}
        \label{fig:3majre}
    \end{subfigure}
    \hspace{0.05\textwidth}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/majority/5majre.pdf}
        \caption{Problem sa 5 bita.}
        \label{fig:5majre}
    \end{subfigure}
    \begin{subfigure}{0.496\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/majority/7majre.pdf}
        \caption{Problem sa 7 bita.}
        \label{fig:7majre}
    \end{subfigure}
    \caption{Ponašanje sustava na problemu pronalaska bita s najvećom frekvencijom pojavljivanja.}
    \label{fig:states}
\end{figure}

\chapter{Zaključak}


\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

\engtitle{Application of LCS on Classification Problems}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}

